---
layout: post
title: IOS中的MVC模式
date  2015-08-02 00:00:00 +0700
categories: uncategorized

---

## MVC介绍：

```

单例模式官方定义是：MVC本来是存在于Desktop程序中的，M是指数据模型（model），V是指
用户界面（view），C则是控制器（controller）。使用MVC是将M和V的实现代码分离，从而
使同一个程序可以使用不同的表现形式。比如一批统计数据你可以分别用柱状图、饼图来表示。
C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。

```


下面主要从这个图（引用别人的）来说起：
![]({{site.url}}/images/MVC设计模式图.png)

```

再往下面看的同时，我先把自己的理解，说一下，虽然不太贴切，不过还是可以帮助理解的。
1.把controller当成一位导演
2.把model当成一部剧本（里面规定了剧情，套路，演员数，角色设定等数据）
3.把view当成一个一个的演员（人们肉眼可看）
他们3个之间的关系是，
1.演员按照剧本的规定数据，来合理演绎和展示。
2.导演负责当作剧本和演员的桥梁，如果剧本由改动，由导演告知演员，演员再去根据新剧本展现。
3.如果演员觉得戏份太少，需要添加一些剧本剧情，需要告知导演，有导演来修改剧本！

```

好了，下面看下，比较正规的解释：


图中有几条线把这三部分划分开，有黄线，虚线，和白色的实线。我们把它们想象成路标。
你可以看到，在M和V之间有两条黄线，这表示什么呢？它意味着你不能 穿越这黄线，
任何一个方向都不行，即M和V完全分离。在图的上部，你可以看到白色的虚线，它意味
着你可以自由的穿越它，只要是安全的。那白色的实线呢？它代表你可以穿越，但你必须
要买票，或者交点过路费.

首先， 我们来看C和M之间的绿色箭头，这箭头的方向就代表着“发起对话”的方向，也就是说，
发起对话的是C，而做出回答的是M。C可以问M各种各样的问题，但M 只是回答C的问题或要求，
它不可以主动的向C要求什么。还记得虚线是畅通无阻的意思吧，所以，C知道M的所有的事情,
如果用代码来说明这件事情，就是 说，C可以导入M的头文件或是M的接口（API）。因为C可以
通过M的API，所以它就可以肆无忌惮的向M要求这要求那了。

我们再来看看另外的一个绿色箭头，它是在C和V之间，和前一个绿色箭头的意义一样，它代表C
可以直接地向V进行交流。你可以想想，C要把V放到屏幕 上，并设置V的属性，告诉它们什么时
候从屏幕上消失，把它们分成组等等。如果C不能自由的向V发号施令的话，程序的显示将会多么
的困难,所以，C可以毫无 限制地向V说话。

可能你已经注意到了，这个箭头上还有outlet(输出口)，outlet可以看作是从C指向V的指针，
它在C中被定义。outlet给我们提供了很大的 方便，它使我们在C的内部就可以轻松准确地向V
施令。C可以拥有很多的outlet，可以不止一个，这也使它可以更高效的和V进行交流。

那M和V之间可以交流么？还记得黄线的意思么？完全不可以通过，所以我们是不允许M和V进行交
流的。这是因为我们不希望这三部分之间有过多的交流，你想想，假如V在显示时出现了问题，比
如有一个图形没有显示出来，我们就要去查找错误，因为C可以和V交流，M也可以和V交流的话，我
们就要去检查两个部分。 相反的，只有C可以和V交流的话，在出错时，我们就只需要去C那里查找
原因，这样查找错误不就很是简单了么？所以，我们不允许M和V之间有直接的联系，这 也是在它们
两之间有两根黄线的原因。 总结下来也就是以下三点：

- Model和View永远不能相互通信，只能通过Controller传递
- Controller可以直接与Model对话（读写调用Model），Model通过Notification和KVO机制
与Controller间接通信
- Controller可以直接与View对话，通过outlet,直接操作View,outlet直接对应到View中的
控件,View通过action向Controller报告事件的发生(如用户Touch我了)。Controller是View
的直接数据源（数据很可能是Controller从Model中取得并经过加工了）。Controller是View的
代理（delegate),以同步View与Controller。

ok,看到这里，估计还是不太明白说了什么东东，下面是对上面提到的几点的进一步说明：

### V对C的交流有三种不同的方式

#### 第一种我们称为目标操作(target-action)
它是这样工作的，C会在自己的内部“悬挂”一个目标(target)，如图中的红白相间的 靶子，对应的
，它还会分发一个操作(action，如图中的黄色箭头)给将要和它交流的视图对象(可能是屏幕上的一个
按钮)，当按钮被按时，action 就会被发送给与之对应的target，这样V就可以和C交流了。但是在这种
情况下，V只是知道发送action给对应的target,它并不知道C中的 类，也不知道它到底发送了什么。
target-action是我们经常使用的方法。

例如下面给uibutton加Sel时就是执行这个操作！

```

[button addTarget:self action:@selector(test) forControlEvents:UIControlEventTouchUpInside];

```

#### 第二种方式我们叫做委托(delegate)
有时候，V需要和C进行同步，你知道，用户交互不仅仅是什么按按钮，划滑块，还有很多种形式。
好了， 让我们来看看图中的delegate黄色箭头，你发现箭头上又分出了四个小箭头：should，
did，will，还有一个没标注的。绝大部分的 delegate信息都是should，will，did这三种
形式。和英文意思相对应，should代表视图对象将询问C中的某个对象“我应该这么做 么？”，举个
例子，有一个web视图，有人点击了一个链接，web视图就要问“我应该打开这个链接么？这样做安
全么？”。这就是should信息。那 will和did呢？will就是“我将要做这件事了”，did就是“我已
经做了这件事”。C把自己设置为V的委托(delegate),它让V知道：如 果V想知道更多的关于将如
何显示的信息的话，就向C发送delegate信息。通过接受V发过来的delegate信息，C就会做出相
应的协调和处理。还 有一点，每个V只能有一个delegate

#### 第三种方式就是数据源(datasource)

V不能拥有它所要显示的数据，记住这点非常重要。V希望别人帮助它管理将要显示的数据，当 它需要
数据时，它就会请求别人的帮助,把需要的数据给它。再者，iphone的屏幕很小，它不能显示包含大
量信息的视图。看图中的datasource箭 头，和delegate类似，V会发送cout，data at信息
给C来请求数据。

例如：如下操作都是滴

```
- (BOOL)tabBarController:(UITabBarController *)tabBarController
shouldSelectViewController:(UIViewController *)viewController NS_AVAILABLE_IOS(3_0);
- (void)tabBarController:(UITabBarController *)tabBarController
didSelectViewController:(UIViewController *)viewController;

```
这里就是以UITabBarController的代理为例子。

好了，到了这里，应该明白了，MVC在ios中，到底用到了哪里了吧Y(^_^)Y！
